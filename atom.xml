<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Vollate&#39;s Blog</title>
  
  
  <link href="http://blog.vollate.top/atom.xml" rel="self"/>
  
  <link href="http://blog.vollate.top/"/>
  <updated>2023-11-03T15:49:16.132Z</updated>
  <id>http://blog.vollate.top/</id>
  
  <author>
    <name>Vollate</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>CPP随笔</title>
    <link href="http://blog.vollate.top/2023/11/03/cpp-essay/"/>
    <id>http://blog.vollate.top/2023/11/03/cpp-essay/</id>
    <published>2023-11-03T03:20:31.000Z</published>
    <updated>2023-11-03T15:49:16.132Z</updated>
    
    <content type="html"><![CDATA[<p>记录cpp编程过程中的一些总结和感想</p><h2 id="含非智能指针类的注意事项">含非智能指针类的注意事项</h2><p>为含有指针的类的写函数是一个很麻烦的事情，总结了一下经验:</p><ul><li>移动构造函数和移动赋值运算符：需要检查<code>this!=&amp;that</code>，防止自我赋值后把自己数据删除的情况。</li><li>涉及到资源的指针的拷贝，移动的：移动指针可能导致无法正常释放，拷贝指针可能导致外界使用悬空指针（释放过的指针）</li><li>所有会用到该类引用/指针的非const成员函数：同移动构造一样需要检查<code>this!=&amp;that</code>，防止函数执行过程中 that 数据改变影响自身数据。eg：假设有一个mString类，有一个insert(size_t index,size_t count, const mString&amp;)成员方法，如果进行a.insert(0,20,a)而内部实现使用循环插入就会出问题</li><li>所有会更改/依赖多个实例pointer的值进行操作的函数。eg:(std::swap)</li></ul><p>带裸指针的类写起来非常头疼，一不小心就会出问题。建议非极度性能或特殊需求（写驱动等），或者<s>折磨</s>锻炼自己的情况还是乖乖用智能指针吧。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;记录cpp编程过程中的一些总结和感想&lt;/p&gt;
&lt;h2 id=&quot;含非智能指针类的注意事项&quot;&gt;含非智能指针类的注意事项&lt;/h2&gt;
&lt;p&gt;为含有指针的类的写函数是一个很麻烦的事情，总结了一下经验:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;移动构造函数和移动赋值运算符：需要检查&lt;code&gt;thi</summary>
      
    
    
    
    <category term="C++" scheme="http://blog.vollate.top/categories/C/"/>
    
    
    <category term="Essay" scheme="http://blog.vollate.top/tags/Essay/"/>
    
  </entry>
  
  <entry>
    <title>Effective C++</title>
    <link href="http://blog.vollate.top/2023/10/05/Effective-CPP/"/>
    <id>http://blog.vollate.top/2023/10/05/Effective-CPP/</id>
    <published>2023-10-05T08:03:48.000Z</published>
    <updated>2023-11-03T15:49:16.132Z</updated>
    
    <content type="html"><![CDATA[<p>从vimwiki迁移过来的古早笔记,仔细看看发现好多忘了(</p><pre><code>Items from 1 to 55</code></pre><hr><ol><li><p>将cpp看作C，面向对象的cpp，模板和STL四个部分；根据各个部分的不同特性选择不同的编程方式</p></li><li><p>能用const，enum，inline就别#define</p></li><li><p>能用const就用const</p></li><li><p>确保类初始化后再使用</p><ul><li>尽可能使用列表初始化(原因:operator= first call class’s default consturctor to allocate memory and get address, then do variable assigment)</li><li>避免初始化顺序问题（有关static初始化的问题）</li></ul></li><li><p>知道默认构造，析构，复制构造函数</p><ul><li>一旦创建移动构造||移动赋值操作符，不会生成默认复制构造&amp;&amp;复制运算符，反之亦然</li></ul></li><li><p>小心使用默认生成的类函数</p></li><li><p>若要使用多态，则应将基类析构函数定义为virtual</p></li><li><p>不要让异常离开析构函数</p></li><li><p>不要在构造和析构函数中调用虚函数</p><ul><li>也不是不能用，注意用的时候的类型是基类还是派生类（容易出问题所以不建议用）</li></ul></li><li><p>重载运算符建议返回*this以便连等及其它操作</p></li><li><p>重载操作符时要考虑自己对自己操作的情况</p><ul><li>处理方法：<ol><li>先判断地址</li><li>拷贝后操作拷贝</li></ol></li></ul></li><li><p>拷贝（复制运算符）要完全复制类的内容（包括基类的）</p><ul><li>要复用代码，不要相互调用复制构造函数，而是共同调用一个三方函数</li></ul></li><li><p>RAII: use class to manage resource(<code>unique_ptr &amp; share_ptr</code>)</p></li><li><p>RAII object have specified copy function</p></li><li><p>访问RAII class数据：</p><ul><li>隐式：更方便</li><li>显示：更安全</li></ul></li><li><p>成对使用对应的 <code>new([])</code> &amp; <code>delete([])</code></p></li><li><p>单独创建智能指针<br><code>eg: A(std::unique_ptr&lt;B&gt;(new B), fuc())</code></p><ul><li>智能指针创建需要接受 <code>new</code> 返回的地址，而类构造函数执行顺序由编译器决定，如果<code>fuc</code> throw exception,会导致内存泄漏</li></ul></li><li><p>设计良好的interface</p><ul><li>尽可能不让用户写出出错代码</li><li>减少用户碰到管理内存的几率</li><li>shared_ptr总是使用指向类的析构函数，可以防止cross-DLL(object creat in a dynamic link library but delete in a differet DLL)</li></ul></li><li><p>定义类就是定义类型，关注一些细节</p></li><li><p>尽量传const&amp;,对基础类型直接传值(iterator实现是指针，也算)</p></li><li><p>不要返回指向本地临时变量的指针</p></li><li><p>对用户隐藏数据，protected没比public包装好到哪去</p></li><li><p>不用访问data的就别搞成成员函数</p></li><li><p>类型转换需要非成员函数(<code>friend</code>)</p></li><li><p>创建合适的swap函数：</p><ul><li>默认的std::swap执行三次拷贝构造-&gt;解决方案：构造wapper类使用指针来存储数据，交换仅交换指针，并且提供public的swap成员函数</li><li>如果该类不是模板类，需要具体化std::swap给该类;如果该类是模板类则在namespace中重写swap（模板函数）</li><li>调用规则：using <em>+ using std::swap，调用优先级为 模板swap&gt;具体化std::swap&gt;std::swap,因此记得using</em> 和using std::swap</li></ul></li><li><p>尽可能延缓变量的定义（看情况而定）好处：<br>- 避免无用变量构造消耗时间（throw会导致无用<br>- 优化默认构造+复制构造为复制构造</p></li><li><p>尽可能不用cast，尤其dynamic_cast；必须要用，定义函数来隐藏cast（尽量避免用户自己cast）；少用c类型的转型, c++四种cast</p><ul><li>const_cast</li><li>dynamic_cast</li><li>reinterpret_cast</li><li>static_cast<ul><li>static_cast子类转成父类时是产生一个子类中父类的临时拷贝，修改不会映射到原存储</li></ul></li></ul><blockquote><p>cast要小心，搞清楚自己的目的</p></blockquote></li><li><p>尽可能避免返回句柄[引用和指针]</p><ul><li>指向栈中临时变量会寄掉</li></ul></li><li><p>exception safety:</p><ul><li>No resource leak</li><li>No data structures become coorupted</li></ul><p>exception safety function:</p><ol><li>Basic guarantee: after throw, everything in program remain valid</li><li>Strong guarantee: after exception, the program status remain as if the fuction is never called</li><li>Nothrow guarantee: never throw exception(hard to guarantee out of C part in C++)</li></ol><ul><li>Strong guarantee implement: make a copy and modify the copy, then swap them in noexception way(But this need more resource and time, though it’s highly recommand, not always need to provide strong guarantee)</li><li>一般函数需要提供至少要有weak exception guarantee(at least no resource leak)</li></ul></li><li><p>inline function rules:</p><ul><li>limit inline function as small, frequently called functions.</li><li>内联别用模板<br>其它一些东西：<ul><li>一般构造和析构函数不是内联</li><li>能不能内联主要看编译器</li></ul></li></ul></li><li><p>最小化编译依赖关系（通过声明）可以使用：</p><ol><li>handle class</li><li>interface class: increase memory cost for virtual function table<br>编译时只需要重新链接函数就行</li></ol></li><li><p>public inheritance means “is a”(noted that only public do this)</p></li><li><p>继承会隐藏父类（作用域）的变量和函数（当然名称空间也会{使用using解除隐藏</p></li><li><p>pure virtual function; virtual function;non-virtual function; 不要担心虚函数带来的损耗（大多数情况），也不要全是虚函数（一样）</p><ul><li>pure virtual function可以在类外提供实现，如此可以强制子类重写（算是强制注意吧）并减少代码重复</li><li>80~20rule:80% running time spend on 20% code</li></ul></li><li><p>使用none virtual interface idiom 在基类以确保多态在何时调用函数</p><ul><li>使用函数指针成员代替虚函数（好处：可以更改调用的函数(坏处：缺少对非public变量的访问权限</li><li>使用std::function成员代替虚函数</li></ul></li><li><p>重定义非虚函数可能会使得多态出现意想不到的问题(从设计上来说就不应该重定义非虚函数)</p></li><li><p>默认参数值为静态绑定，不同于虚函数的动态绑定，不要在继承中改变默认值</p></li><li><p>has a &amp; implemented in terms of-- composition</p></li><li><p>private inheritance当仅必要时<br>- both private inheritance and composition mean is-implemented-in-terms-of<br>- composition is easy to understand<br>- private inheritance can enable EBO<br>- empty base optomize(EBO):当仅单继承且父类是空类时，子类大小等于数据大小(编译器优化</p></li><li><p>多继承尽量别用，用要考虑virtual</p><ul><li>虚拟继承有损耗（比起单继承</li><li>多继承例子：public interface+private implementation</li></ul></li><li><p>类和模板都支持多态</p><ul><li>对于类，接口是明确的，多态出现在运行时</li><li>对于模板参数，接口是明确且基于合法的表达式的，多态出现在编译时（通过模板初始化和函数重载）</li></ul></li><li><p>typename和class可以互换</p><ul><li>在不清楚的情况下，C++默认把typename(class):😗**看成变量而不是类型，使用 <code>typename</code> 告诉他这是个变量类型</li></ul></li><li><p>访问模板基类函数的三种方法</p><ol><li>使用 <code>this</code> 指针调用</li><li><code>using</code> 指令</li><li><code>base&lt;T&gt;::**</code>直接用</li></ol></li><li><p>模板隐式具体化出的不依赖于模板参数的函数会导致程序膨胀</p><ul><li>若由非类型参数导致，将模板参数换为函数参数或者类成员变量</li><li>若由类型参数导致，可以将数据转化为 无类型指针 <code>eg: static_cast&lt;void*&gt;</code> 然后统一调用</li></ul></li><li><p>在模板类中使用模板成员函数来接受所有合法参数</p><ul><li>eg: 同模板不同具体化类的实例化的复制构造函数和复制运算符</li><li>注意：即使声明了模板复制构造函数，也要声明一般的复制构造函数</li></ul></li><li><p>我不知道他想说明啥</p></li><li><p>特化模板类使其对特定类型使用特定函数</p><ul><li>通过 <code>tyepid()</code> 检查—wrong, can’t compile<ul><li>由于不同的类型支持不同的函数，一些不支持的函数无法被编译（即使<code>if else</code>永远不会进入)编译过程要求所有代码合法</li></ul></li><li>通过和函数重载(编译时)</li></ul></li><li><p>TMP(template metaprogramming)</p><ul><li>将一部分运行时工作放到编译时进行</li></ul></li><li><p>通过 <code>set_new_handler(*new_handler)</code> 自定义new的行为 <code>typedef void (*new_handler)()</code> declear in std, use as <code>std::new_handler</code></p><ul><li>通过连锁调用在失败后尝试其他 <code>handler</code> 分配内存，最后全部失败再throw bad_alloc</li><li>自定义类new的行为: modify <code>void* operator new(std::size)throw(std::bad_alloc)</code> and <code>set_new_handler</code></li><li>C++93前new分配失败会返回0，使用 <code>new(std::nothrow)</code> 来启用这一行为（只作用于内存分配时，初始化相关对象仍可能throw</li></ul></li><li><p>重载new/delete操作符的几种情况</p><ol><li>优化操作速度</li><li>收集内存使用信息</li><li>减少开头和末尾的内存占用</li><li>自定义内存对齐</li><li>将类集束摆放</li><li>其他未列出new行为</li></ol></li><li><p>重载new和delete</p><ul><li>重载new需要一个无限循环来分配内存，并在失败时调用 <code>set_new_handler</code> 或者分配0空间并throw</li><li>对于类类型，应该分配比预期更大空间</li><li>delete对nullptr什么也不做，对类类型应该删除比预期更大空间</li></ul></li><li><p>重写new了记得重写delete，并且不要无意间隐藏了默认的new&amp;delete</p></li><li><p>注意编译警告，也不要过度依赖编译器</p></li><li><p>熟悉标准库，包括</p><ul><li>STL(standard template library)</li><li>Iostream</li><li>Internationlization(like wchar_t,wstring)</li><li>numeric provessing(valarray, complex)</li><li>exception hierarchy</li><li>C89 standard library</li><li>tr1(2005,Technical report 1), add smartPointers,function pointers(tr1::function,std::function now)就是std::expermental::xxx</li></ul></li><li><p>Boost organization and Boost library</p></li></ol><hr><p>This is just a begining, C++ learning will never end</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;从vimwiki迁移过来的古早笔记,仔细看看发现好多忘了(&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Items from 1 to 55
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;将cpp看作C，面向对象的cpp，模板和STL四个部分；根据各个部分的不同特性选择</summary>
      
    
    
    
    <category term="C++" scheme="http://blog.vollate.top/categories/C/"/>
    
    
    <category term="Note" scheme="http://blog.vollate.top/tags/Note/"/>
    
  </entry>
  
  <entry>
    <title>Book List</title>
    <link href="http://blog.vollate.top/2023/09/18/book-list/"/>
    <id>http://blog.vollate.top/2023/09/18/book-list/</id>
    <published>2023-09-18T04:18:11.000Z</published>
    <updated>2023-11-03T15:49:16.132Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Reading">Reading</h2><ul><li>C++ Currency in Action</li><li><s>Computer Organzation And Design</s> 摆了</li><li>RISCV-privileged</li></ul><h2 id="Plan-To-Read">Plan To Read</h2><ul><li>Effective Modern C++</li><li>C++ Templates ed.2</li></ul><h2 id="Shelve">Shelve</h2><ul><li>Deep learning</li></ul><h2 id="Finished">Finished</h2><table><thead><tr><th>Name</th><th>Finish date</th></tr></thead><tbody><tr><td>C++ Primer Plus</td><td>2021.12</td></tr><tr><td>Effective C++</td><td>2022.7</td></tr><tr><td>1984</td><td>2022.6</td></tr><tr><td>沙丘</td><td>2022.6</td></tr><tr><td>资本论</td><td>2022.8.1</td></tr><tr><td>地铁系列(203[3,5])</td><td>2022.9.25</td></tr><tr><td>More Effective C++</td><td>2023.1.22</td></tr><tr><td>The Fast Guide towards Modern C++</td><td>2023.7.15</td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Reading&quot;&gt;Reading&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;C++ Currency in Action&lt;/li&gt;
&lt;li&gt;&lt;s&gt;Computer Organzation And Design&lt;/s&gt; 摆了&lt;/li&gt;
&lt;li&gt;RISCV-privileged&lt;/</summary>
      
    
    
    
    
    <category term="Book" scheme="http://blog.vollate.top/tags/Book/"/>
    
  </entry>
  
  <entry>
    <title>Tool List</title>
    <link href="http://blog.vollate.top/2023/03/27/tool-list/"/>
    <id>http://blog.vollate.top/2023/03/27/tool-list/</id>
    <published>2023-03-27T00:17:41.000Z</published>
    <updated>2023-11-03T15:49:16.132Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>收录了Linux下使用的一些工具</p></blockquote><h2 id="Screen-Shot-Recorder">Screen Shot/Recorder</h2><ul><li><a href="https://www.maartenbaert.be/simplescreenrecorder/">SimpleScreenRecorder</a></li><li><a href="https://obsproject.com/">OBS studio</a></li><li><a href="https://flameshot.org/">flameshot</a></li></ul><h2 id="Cloud-Drive">Cloud Drive</h2><ul><li><a href="https://github.com/abraunegg/onedrive/tree/master">Onedrive</a></li><li><a href="https://github.com/bpozdena/OneDriveGUI">OnedriveGUI</a>: GUI for client above</li></ul><h2 id="Proxy">Proxy</h2><h3 id="Clash-Client">Clash Client</h3><ul><li><a href="https://github.com/Fndroid/clash_for_windows_pkg">cfw</a>(closed-source)</li><li><a href="https://github.com/zzzgydi/clash-verge">clash-verge</a>(open-source)</li></ul><blockquote><p>注意 Clash 和 Clash.Meta 是开源软件，clash.Premium 为 Clash 原作者在 Clash 基础上开发的闭源软件，介意误用</p></blockquote><h3 id="V2ray-Client">V2ray Client</h3><ul><li><a href="https://github.com/v2rayA/v2rayA">v2rayA</a>(open-source)</li></ul><h2 id="Diagram">Diagram</h2><ul><li><a href="https://app.diagrams.net/">drawio</a></li></ul><h2 id="Office">Office</h2><ul><li><a href="https://github.com/LibreOffice/core">libreoffice</a></li><li><a href="https://github.com/ONLYOFFICE/DesktopEditors">onlyoffice</a></li></ul><h2 id="Terminal-Resource-Monitor">Terminal Resource Monitor</h2><ul><li><a href="https://github.com/aristocratos/btop">btop</a> or <a href="https://github.com/aristocratos/bpytop">bpytop</a></li><li><a href="https://github.com/htop-dev/htop">htop</a></li></ul>]]></content>
    
    
    <summary type="html">Useful tools on Linux</summary>
    
    
    
    
    <category term="Tools" scheme="http://blog.vollate.top/tags/Tools/"/>
    
  </entry>
  
  <entry>
    <title>文章/链接归档</title>
    <link href="http://blog.vollate.top/2022/11/10/blog-archives/"/>
    <id>http://blog.vollate.top/2022/11/10/blog-archives/</id>
    <published>2022-11-10T20:10:57.000Z</published>
    <updated>2023-11-03T15:49:16.132Z</updated>
    
    <content type="html"><![CDATA[<h2 id="OS">OS</h2><ul><li><a href="https://bbs.huaweicloud.com/blogs/279735">内存管理</a></li></ul><h2 id="Program">Program</h2><ul><li><a href="https://www.foonathan.net/2016/03/cmake-install/">CMake export lib</a></li><li><a href="https://www.cnblogs.com/pcdack/p/16019319.html">oneAPI|DPC++归档</a></li></ul><h2 id="Network">Network</h2><ul><li><a href="https://gfw.report/">GFW report</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;OS&quot;&gt;OS&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://bbs.huaweicloud.com/blogs/279735&quot;&gt;内存管理&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;Program&quot;&gt;Program&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;</summary>
      
    
    
    
    <category term="Archive" scheme="http://blog.vollate.top/categories/Archive/"/>
    
    
    <category term="Archive" scheme="http://blog.vollate.top/tags/Archive/"/>
    
  </entry>
  
  <entry>
    <title>Happy Runner (乐道不跑)</title>
    <link href="http://blog.vollate.top/2022/11/03/happy-runner/"/>
    <id>http://blog.vollate.top/2022/11/03/happy-runner/</id>
    <published>2022-11-03T02:57:19.000Z</published>
    <updated>2023-11-03T15:49:16.132Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Requirement">Requirement</h2><p>一部root了的安卓手机(解不了bl的可以试试太极)</p><blockquote><p>如何root建议google,据说小米开模糊定位不root也行，但是没试过(没有没root的手机)</p></blockquote><h2 id="Steps">Steps</h2><ol><li>下载<a href="http://fakeloc.cc/app">fake location</a>，链接挂了就上 github 搜</li><li>买高级版 (花钱)</li><li>设置里面把地图换成百度</li><li>路线模拟里面画路线，<s>建议把每个可能的打卡点都过一遍</s> 现在不用打卡了,差不多就行，注意别超过单次最大路程</li><li>开启路线模拟和乐跑，设置速度(注意别太快了)，建议开启浮动速度和模拟步频</li><li>记得到时间来关乐跑免得超时</li></ol><h2 id="问题排查">问题排查</h2><ul><li>开了模拟没反应: 换运行模式(root/no root)</li><li>乐跑闪退(root了的手机/模拟器): 对乐跑隐藏root(Magisk/fake location 内置)</li><li>目前最新版乐跑好像不能在模拟器中运行，大概是检测模拟器？</li><li>其他: 看文档, google，<s>我有一个朋友</s></li></ul><p><strong>本教程仅供参考，使用有风险，对于按照本教程操作造成被检测等等问题概不负责</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Requirement&quot;&gt;Requirement&lt;/h2&gt;
&lt;p&gt;一部root了的安卓手机(解不了bl的可以试试太极)&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;如何root建议google,据说小米开模糊定位不root也行，但是没试过(没有没root的手机)&lt;/p</summary>
      
    
    
    
    <category term="Tips" scheme="http://blog.vollate.top/categories/Tips/"/>
    
    
    <category term="Magic" scheme="http://blog.vollate.top/tags/Magic/"/>
    
  </entry>
  
  <entry>
    <title>First Post</title>
    <link href="http://blog.vollate.top/2022/10/01/first-post/"/>
    <id>http://blog.vollate.top/2022/10/01/first-post/</id>
    <published>2022-10-01T03:12:59.000Z</published>
    <updated>2023-11-03T15:49:16.132Z</updated>
    
    <content type="html"><![CDATA[<p>总算整了个能看的blog界面</p><p>之前搭图床然后疯狂报错<br>最后发现发现设置nginx的时候location拼错了~~(不开高亮的下场)~~</p><p>总之捣鼓了快一个月想起来弄一下断断续续的终于配好了</p><p><img src="514.png" alt="恋恋可爱捏"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;总算整了个能看的blog界面&lt;/p&gt;
&lt;p&gt;之前搭图床然后疯狂报错&lt;br&gt;
最后发现发现设置nginx的时候location拼错了~~(不开高亮的下场)~~&lt;/p&gt;
&lt;p&gt;总之捣鼓了快一个月想起来弄一下断断续续的终于配好了&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;514.png&quot;</summary>
      
    
    
    
    
  </entry>
  
</feed>
