<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Vollate&#39;s Blog</title>
  
  
  <link href="http://blog.vollate.top/atom.xml" rel="self"/>
  
  <link href="http://blog.vollate.top/"/>
  <updated>2023-12-07T16:22:28.555Z</updated>
  <id>http://blog.vollate.top/</id>
  
  <author>
    <name>Vollate</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>南科大记录</title>
    <link href="http://blog.vollate.top/2023/11/24/sustech/"/>
    <id>http://blog.vollate.top/2023/11/24/sustech/</id>
    <published>2023-11-24T15:10:03.000Z</published>
    <updated>2023-12-07T16:22:28.555Z</updated>
    
    <content type="html"><![CDATA[<p>记录南科大发生的那些事</p><h2 id="2023-fall">2023 fall</h2><h3 id="11-23">11.23</h3><p>送的是分，没的是木琴。今天可以送分，明天是不是就出点卡了。本来选课就是教学资源不够情况下的一种折中，现在连基本的公平也没了。还有南科大经典的先发通知，学生不满再说，第一封邮件貌似只给选了哪门课的学生发了(~<s>好像只有23级</s> 本人和周边许多同学都没有收到这封邮件)，摆明了想把学生当傻子耍。<br><img src="%E7%A7%AF%E5%88%86%E9%80%89%E8%AF%BE.jpg" alt="1"><br><img src="%E7%89%88%E6%9C%AC%E9%81%A5%E9%81%A5%E9%A2%86%E5%85%88.jpg" alt="2"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;记录南科大发生的那些事&lt;/p&gt;
&lt;h2 id=&quot;2023-fall&quot;&gt;2023 fall&lt;/h2&gt;
&lt;h3 id=&quot;11-23&quot;&gt;11.23&lt;/h3&gt;
&lt;p&gt;送的是分，没的是木琴。今天可以送分，明天是不是就出点卡了。本来选课就是教学资源不够情况下的一种折中，现在连基本的公平</summary>
      
    
    
    
    <category term="SUSTech" scheme="http://blog.vollate.top/categories/SUSTech/"/>
    
    
  </entry>
  
  <entry>
    <title>浅记系统虚拟化</title>
    <link href="http://blog.vollate.top/2023/11/17/virtualization/"/>
    <id>http://blog.vollate.top/2023/11/17/virtualization/</id>
    <published>2023-11-17T11:24:06.000Z</published>
    <updated>2023-12-07T16:22:28.555Z</updated>
    
    <content type="html"><![CDATA[<p>最近由于项目需要学习虚拟化的知识，于是在师兄的建议下读了 sjtu 出的新书<a href="https://ipads.se.sjtu.edu.cn/ospi/">《操作系统原理与实践》</a>中的系统虚拟化的部分，随便记点笔记。</p><p><strong>虚拟化发展历史:</strong></p><ul><li>1960s出现分时操作系统概念。同时期IBM进行了另一个方向也就是虚拟化的探索，并在1968年的system360上实现了第一个VMM(Virtual Machine Monitor) <em>CP/CMS</em></li><li>1980s，开始出现纯软件实现的虚拟机监视器</li><li>1990s, 互联网兴起，web服务器逐渐性能过剩</li><li>1998年，VMware成立。</li><li>云计算兴起，虚拟化越发重要</li></ul><p><strong>优势:</strong></p><ul><li>充分利用服务器性能，<s>搞超售</s></li><li>虚拟机管理更为便捷，可以快速部署销毁</li><li>可以热迁移</li><li>VMI (Virtual Machine Introspection 虚拟机自省)可以从外部检查虚拟机是否被入侵</li></ul><h2 id="系统虚拟化概述">系统虚拟化概述</h2><h3 id="组成部分">组成部分</h3><ul><li>CPU 虚拟化（vCPU）：若虚拟化的指令集和物理架构指令集相同，除了部分特殊指令其他都可以直接执行，效率较高（KVM）；若架构不同，则需要全部转译执行。</li><li>内存虚拟化：引入虚拟物理地址，内存访问需要多经过一层虚拟物理地址到物理地址的映射操作。</li><li>I/O 虚拟化：VMM 提供虚拟驱动供虚拟机使用，并将操作转化为实际的物理设备访问或其他操作。</li></ul><h3 id="VMM-类型">VMM 类型</h3><ul><li>半虚拟化: 运行在最高权限级别，相当于一个以OS作为进程的操作系统，如 Xen。</li><li>完全虚拟化：作为一个进程运行在 OS 上，复用宿主OS的线程调度和资源管理，如 QEMU。</li></ul><h2 id="Trap-Emulate（下陷-模拟）">Trap-Emulate（下陷-模拟）</h2><p>Trap：将系统级ISA拦截转由 VMM 进行模拟操作。如系统调用先转化为虚拟机内核态，然后由 VMM 拦截并完成对应调用的模拟。</p><p>Emulate：用软件模拟执行后的副作用</p><p><strong>基础概念:</strong></p><ul><li>CPU 上下文：指CPU在执行特定进程或任务时所需的信息集合。一般包括该CPU的所有寄存器（包括PC）的值和当前系统状态（内存信息，调度优先级等）。</li><li>中断向量表（Interrupt Vector Table）：存放中断处理函数。</li><li>中断处理过程：触发中断时，首先检查中断是否开启。若开启，CPU 接收中断信号并暂停当前程序处理。然后保存当前上下文以供恢复。然后确定中断类型并从中断向量表中查找对应处理函数的地址并跳转执行。执行结束后，恢复中断前的上下文。</li><li>用户态：用户态是普通应用程序运行的模式。该模式下，程序对硬件的访问受限，一般通过OS提供系统调用切换到内核态来执行对应函数进行访问。</li><li>内核态：OS 一般运行在该状态下。该状态下，OS 能够完全访问并操作硬件，访问所有内存。</li></ul><h3 id="Trap-Emulate-虚拟化实现">Trap-Emulate 虚拟化实现</h3><p>VMM 需提供数据结构，来存储原本存储在物理 CPU 上的所有进程上下文信息，以及对应的其它信息（如中断向量表,虚拟页表等）。</p><ul><li>处理中断：对于硬件中断，将会触发 VMM 查看虚拟机是否开启对应中断。如开启，虚拟机保存上下文后下陷到 VMM，然后 VMM 检查中断向量表处理中断。</li><li>处理系统调用：同中断处理的模式，只是 VMM 需要隔离用户态和内核态的页表映射</li><li>处理线程切换：本质软件中断到内核态然后进行线程调度，切换进程上下文即可。</li><li>多 CPU 模拟：加个数据结构存进程上下文和 vCPU 的对应关系就行。vCPU 调度参考 OS 的进程调度，或者直接用线程 OS 进程来实现。</li></ul><h2 id="CPU虚拟化">CPU虚拟化</h2><p>特权指令：在用户态执行时会下陷进入特权级的指令</p><p>敏感指令：管理物理硬件资源或更改CPU状态的指令</p><p>eg：</p><ul><li>x86 修改 CR 寄存器的值</li><li>读写敏感内存</li><li>I/O 指令</li></ul><h3 id="可虚拟化和不可虚拟化架构">可虚拟化和不可虚拟化架构</h3><p>所有满足敏感指令都是特权指令的架构称为可虚拟化架构，反之则为不可虚拟化架构。</p><p>eg:</p><ul><li>AArch32</li><li>早期 x86</li></ul><h3 id="弥补不可虚拟化架构的方法">弥补不可虚拟化架构的方法</h3><h4 id="全虚拟化">全虚拟化</h4><p><em>适用于无需修改客户端源码的情况</em></p><ul><li>解释执行：用纯软件模拟cpu执行指令过程。具体操作是对于每条指令调用对应的用于模拟的函数，整个过程不产生任何下陷。优点是可以模拟任何 ISA 类型的虚拟机。缺点显而易见，效率低下。</li><li>动态二进制编译：在解释执行的基础上将程序划分为只有一个入口和一个出口,中间无任何修改控制流指令的代码块(相当于创建了一个函数)。第一次执行该块时进行翻译并缓存，之后再执行时调用之前的缓存。翻译替换所有敏感指令，在块的末尾添加一条跳转指令来通知 VMM 执行完毕。</li><li>扫描-翻译：用于虚拟机架构和宿主相同的情况，在程序执行前扫描可能存在敏感指令的代码，翻译并缓存翻译后的代码以便下次复用。大多数情况敏感指令只存在于 OS kernal 中，可以只扫描内核代码。</li></ul><h4 id="半虚拟化">半虚拟化</h4><blockquote><p>在允许修改虚拟机客户端代码的情况下可以使用</p></blockquote><p>原理：通过 VMM 提供的类似系统调用的服务使得虚拟机内核不再需要下陷模拟，而是类似进程使用系统调用一样进行对应操作，效率更高。半虚拟化使得 VMM 获得查看客户端内存分布的能力，能够更合理的分配资源。</p><h4 id="硬件虚拟化">硬件虚拟化</h4><p>通过 CPU 硬件支持来实现更高效的虚拟化。具体来说就是增加一个专为 VMM 运行的特权级，该特权级下 VMM 拥有和宿主 OS 相同的硬件访问权限，来节省下陷的开销。</p><p>拓展——KVM (kernal-based virtual machine) 技术: 通过将 VMM 作为内核模块加载使得 VMM 能够使用 宿主 OS 内核的功能，这样下陷时某些支持的架构可以消除 KVM 到 OS 内核特权级转换带来的开销。指令无需翻译，直接在硬件上执行，使得虚拟化效率接近直接运行。</p><h2 id="内存虚拟化">内存虚拟化</h2><p>目标：实现虚拟机之间，虚拟机和物理机之间的内存隔离<br>术语：</p><ul><li>GVA: Guest Virtual Address</li><li>GPA: Guest Physical Address</li><li>HPA: Host Physical Address</li></ul><h3 id="影子页表-Shadow-Page-Table">影子页表(Shadow Page Table)</h3><p>复习进程页表的配置&amp;使用：</p><ol><li>调用前 OS 为进程配置一个虚拟地址映射到物理地址的静态页表（相对地址）</li><li>OS 将页表基地址写入对应寄存器以让 MMU 能找到页表</li><li>MMU 解析虚拟地址到物理地址</li></ol><p>内存虚拟化中，VMM 需要根据存储的 GPA 到 HPA 的映射信息并生成一个 GVA 到 HPA 的影子页表。在虚拟机下陷时,将页表基地址替换为影子页表基地址，从而让 MMU 直接解析 GVA。</p><p>VMM 需要监视虚拟机对页表的更改，并对应地修改影子页表。同时为了分隔用户态和内核态，需要分离对应的页表，使得用户态页表中不包含内核态的映射</p><p>缺页处理：</p><ul><li>若为页表项不存在或无权限，VMM 需触发宿主 OS 的缺页中断进行处理</li><li>若为访问权限足够，则需要同步影子页表与虚拟机页表</li></ul><h3 id="直接页表映射">直接页表映射</h3><p>客户端与宿主共用页表。该情况下客户端知道自己处在虚拟环境中，VMM 会告知客户端可以使用的页表范围，方便客户端规划。客户端的页表项被设为只读，修改页表需要使用 VMM 提供的超级调用，该调用会检查对页表的修改是否合法。</p><h3 id="两阶段地址翻译">两阶段地址翻译</h3><p>硬件虚拟化的一部分，需要 CPU 支持使用第二页表将 GPA 转换到 HPA，省去 VMM 手动维护影子页表的步骤。同时可以使用 TLB 来优化解析速度。</p><p>缺页中断处理：</p><ul><li>客户虚拟机缺页：无需下陷，硬件直接调用虚拟机注册的中断函数</li><li>第二阶段页表缺页：下陷，硬件直接调用 VMM 注册的的对应中断函数</li></ul><p>优点：</p><ul><li>不用维护影子页表</li><li>不用为每个进程维护一个页表</li><li>缺页处理更快</li></ul><h3 id="换页和内存气球">换页和内存气球</h3><p>目的：运行时动态调整虚拟机内存大小，<s>内存超售</s></p><p><strong>换页逻辑</strong>：</p><ul><li>保存将要交换的页的 GVA 和 GPA</li><li>交换页内数据到持久化存储设备（硬盘什么的）</li><li>将客户端页表项设为 INVALID</li><li>VMM 重新分配该页</li></ul><p><strong>内存气球(Memory Ballooning)</strong>：在客户端插入一个驱动(<s>内鬼</s>)，该驱动根据 VMM 的要求使用虚拟机的接口申请/释放内存，然后将申请的内存物理地址告诉 VMM 来使用。</p><h2 id="I-O虚拟化">I/O虚拟化</h2><ul><li>限制虚拟机对物理硬件的直接访问</li><li>提供虚拟设备接口</li><li>充分利用I/O</li></ul><h3 id="软件模拟（全虚拟化）">软件模拟（全虚拟化）</h3><p>捕获客户端对虚拟硬件的 MMIO, DMA, 中断，下陷后由 VMM 执行对应操作</p><h3 id="半虚拟化-2">半虚拟化</h3><p>类似全虚拟化，客户端不再使用原生驱动而是前端驱动，用于与 VMM 后端驱动交互。 通过内存共享传递数据，并使用批处理加速，由后端驱动完成和物理硬件的交互。</p><h3 id="设备直通">设备直通</h3><p>让客户端直接管理硬件设备，此时操作对应硬件不会产生任何下陷。为防止 DMA 攻击使用 IOMMU 进行二阶段 GPA 到 HPA 的映射并检查对应权限。</p><p>SR-IOV(single root I/O virtualization):实现硬件层面 IO 虚拟化，避免单一虚拟机独占硬件。通过创建多个 VF （virtual function） 让 VMM 分配给虚拟机使用</p><h2 id="中断虚拟化">中断虚拟化</h2><p>两种中断：</p><ul><li>物理中断：由硬件产生，在非直通情况下由 VMM 处理</li><li>虚拟中断：由 VMM 产生</li></ul><p>解决开关中断下陷的问题：增加可供虚拟机修改中断而无需下陷的虚拟寄存器</p><p>直接向虚拟机发送中断：增加一个中断翻译表，用于将物理中断翻译为虚拟机对应的中断。因此无需再进行下陷。</p><h2 id="QEMU-KVM">QEMU/KVM</h2><p>略</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;最近由于项目需要学习虚拟化的知识，于是在师兄的建议下读了 sjtu 出的新书&lt;a href=&quot;https://ipads.se.sjtu.edu.cn/ospi/&quot;&gt;《操作系统原理与实践》&lt;/a&gt;中的系统虚拟化的部分，随便记点笔记。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;虚拟化发展</summary>
      
    
    
    
    <category term="OS" scheme="http://blog.vollate.top/categories/OS/"/>
    
    
    <category term="Note" scheme="http://blog.vollate.top/tags/Note/"/>
    
  </entry>
  
  <entry>
    <title>折腾博客记录</title>
    <link href="http://blog.vollate.top/2023/11/13/fiddle-blog/"/>
    <id>http://blog.vollate.top/2023/11/13/fiddle-blog/</id>
    <published>2023-11-13T09:02:27.000Z</published>
    <updated>2023-12-07T16:22:28.551Z</updated>
    
    <content type="html"><![CDATA[<p>原来的 vps 到期了，不想续费新开了一台，忘了全系统备份了。索性新 vps 改成 Debian，blog 扔 github page,然后又是一顿折腾。</p><h2 id="Github-Action-样例">Github Action 样例</h2><p>改了改 Hexo 官网的:</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">name:</span> <span class="string">Blog</span></span><br><span class="line"></span><br><span class="line"><span class="attr">on:</span></span><br><span class="line">  <span class="attr">push:</span></span><br><span class="line">    <span class="attr">branches:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">main</span></span><br><span class="line"><span class="attr">jobs:</span></span><br><span class="line">  <span class="attr">pages:</span></span><br><span class="line">    <span class="attr">runs-on:</span> <span class="string">ubuntu-latest</span></span><br><span class="line">    <span class="attr">permissions:</span></span><br><span class="line">      <span class="attr">contents:</span> <span class="string">write</span></span><br><span class="line">    <span class="attr">steps:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">uses:</span> <span class="string">actions/checkout@v3</span></span><br><span class="line">        <span class="attr">with:</span></span><br><span class="line">          <span class="attr">token:</span> <span class="string">$&#123;&#123;</span> <span class="string">secrets.GITHUB_TOKEN</span> <span class="string">&#125;&#125;</span></span><br><span class="line">          <span class="attr">submodules:</span> <span class="literal">true</span>   </span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Use</span> <span class="string">Node.js</span> <span class="number">18.</span><span class="string">x</span></span><br><span class="line">        <span class="attr">uses:</span> <span class="string">actions/setup-node@v2</span></span><br><span class="line">        <span class="attr">with:</span></span><br><span class="line">          <span class="attr">node-version:</span> <span class="string">&quot;18&quot;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Install</span> <span class="string">Dependencies</span></span><br><span class="line">        <span class="attr">run:</span> <span class="string">npm</span> <span class="string">install</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Build</span></span><br><span class="line">        <span class="attr">run:</span> <span class="string">npm</span> <span class="string">run</span> <span class="string">build</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Deploy</span></span><br><span class="line">        <span class="attr">uses:</span> <span class="string">peaceiris/actions-gh-pages@v3</span></span><br><span class="line">        <span class="attr">with:</span></span><br><span class="line">          <span class="attr">github_token:</span> <span class="string">$&#123;&#123;</span> <span class="string">secrets.GITHUB_TOKEN</span> <span class="string">&#125;&#125;</span></span><br><span class="line">          <span class="attr">publish_dir:</span> <span class="string">./public</span></span><br></pre></td></tr></table></figure><h2 id="Github-Action-禁用-jekyll-build">Github Action 禁用 jekyll build</h2><p>因为要用 <code>peaceiris/actions-gh-pages@v3</code> 进行部署，但是用的 Hexo 且已经在先前的操作编译完成，只需部署到对应分支即可。</p><p><s>一开始不知道 debug 了半天</s> 解决方法在仓库里创建一个<code>.nojekyll</code>文件即可, 这会自动禁用 jekyll build 而只执行 deploy (部署编译好的文件到对应分支)</p><h2 id="使用cf后无限redirect">使用cf后无限redirect</h2><p>在 namesilo 买的域名，突发奇想试试用 Cloudflare 免费计划的域名解析（<s>为了CDN</s>）</p><p>配完后炸了，http 请求返回 301 导致无限 redirect，查了下原因如下：</p><blockquote><p>服务器端使用了强制HTTPS，CloudFlare 的Flexible策略原理是：用户访问时使用HTTPS访问到CF的节点，然后CF通过HTTP方式回源到你的服务器去读取数据，这个时候对于你的服务器来说，CF就是访客，所以服务器返回的状态都是 301。解决方法很简单，将 SSL 策略设为 Full 或者 Full(strict) 就能解决。</p><footer><strong>Vanish</strong><cite><a href="https://vzone.me/897/">vzone.me/897</a></cite></footer></blockquote><hr><h2 id="上大学上的-jpg"><s><strong>上大学上的.jpg</strong></s></h2><p><img src="fiddle-with-ddl.jpg" alt="ddl fuck you"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;原来的 vps 到期了，不想续费新开了一台，忘了全系统备份了。索性新 vps 改成 Debian，blog 扔 github page,然后又是一顿折腾。&lt;/p&gt;
&lt;h2 id=&quot;Github-Action-样例&quot;&gt;Github Action 样例&lt;/h2&gt;
&lt;p&gt;改了改 </summary>
      
    
    
    
    <category term="Network" scheme="http://blog.vollate.top/categories/Network/"/>
    
    <category term="CI/CD" scheme="http://blog.vollate.top/categories/Network/CI-CD/"/>
    
    
    <category term="Fiddle" scheme="http://blog.vollate.top/tags/Fiddle/"/>
    
  </entry>
  
  <entry>
    <title>More Effecitve C++</title>
    <link href="http://blog.vollate.top/2023/11/08/more-effecitve-cpp/"/>
    <id>http://blog.vollate.top/2023/11/08/more-effecitve-cpp/</id>
    <published>2023-11-08T08:21:57.000Z</published>
    <updated>2023-12-07T16:22:28.555Z</updated>
    
    <content type="html"><![CDATA[<ul><li>不能直接往数组类容器塞多态类，使用指针；一定要引用的情况下（需要<code>operator()</code>）用std::reference</li><li>直接创建数组或用vector,array等容器预先分配大小时调用类的无参(默认)构造函数，因此如果用了explict记得声明无参构造函数</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//没有无参构造函数解法（别用）</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Ex</span>;</span><br><span class="line"><span class="type">void</span>* ptr=<span class="keyword">operator</span> <span class="keyword">new</span>[](<span class="number">10</span>*<span class="built_in">sizeof</span>(Ex));</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i!=<span class="number">10</span>;++i)</span><br><span class="line">    <span class="keyword">new</span> (&amp;ptr[i]) <span class="built_in">Ex</span>(...);<span class="comment">//call constructor</span></span><br><span class="line"><span class="comment">//Free memory</span></span><br><span class="line"><span class="function"><span class="keyword">operator</span> <span class="title">delete</span><span class="params">(ptr)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>custom <code>i++&amp;++i</code> for class</li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">foo</span>;</span><br><span class="line"><span class="type">int</span> foo <span class="keyword">operator</span>++();<span class="comment">//++i</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> foo <span class="keyword">operator</span>++(<span class="type">int</span>);<span class="comment">//i++</span></span><br></pre></td></tr></table></figure><ul><li>尽可能不重载 <code>&amp;&amp;</code>,<code>||</code> and <code>,</code>，因为不满足短路逻辑</li><li>有关<code>new</code>, <code>new[]</code>,<code>delete</code>,<code>delete[]</code><ul><li>new时，先调用<code>void* operator new(size_t size)</code>分配内存,然后初始化对象并且将<code>void*</code>转型为对应类型指针</li><li>operator new 的一个重载:<code>void* operator new(size_t size, void* loaction)</code> 定位new实现</li><li>delete时，先调用析构函数然后<code>operator delete</code> 释放内存</li><li>对数组:<ul><li>new []调用<code>operator new[]()</code>分配内存,然后为每个对象调用构造函数</li><li>delete[]同理</li></ul></li></ul></li><li>构造函数异常处理(未完全构造函数不会栈解退自动析构):<ul><li>使用try catch进行清理</li><li>防止成员列表初始化const pointer异常导致资源泄漏的方法(未完全构造指针无法使用delete):<ul><li>调用一个basic exception guarantee的函数</li><li>使用RAII类</li></ul></li></ul></li><li>异常<ul><li>异常栈解退时调用析构函数再抛出异常将会导致程序直接终止(call terminate directly kill program)</li><li>异常拷贝时按照静态类型拷贝(派生类的基类引用拷贝为基类)</li><li>异常捕获的支持隐式转型(按指):<ul><li>任何指针to <code>void*</code>(极其不建议用指针)</li><li>派生类转基类</li></ul></li><li>总是按catch先后顺序捕获</li><li>按引用捕获可以实现多态</li></ul></li><li>Improve proformance:<ul><li>lazy evaluation: 返回一个结果的代理类，只有在需要时才进行计算</li><li>lazy copy： 写时复制</li><li>lazy fetch：涉及到数据库的部分</li><li>over-eager evaluation：提前计算并存入缓存，或constexpr编译期计算</li></ul></li><li>临时对象: 仅在按值传递对象或者传递常量引用参数时产生。返回对象时，若直接返回则会拷贝局部对象</li><li>返回值优化: 返回构造函数的参数，这样返回的对象会在返回的作用域构造(编译器优化)</li><li>判断类是否在堆中(为了确定能否调用<code>delete this</code>)：重载<code>operator new,operator new[]</code>,记录返回的指针到一个图中，每次删除前进行查找是否在堆上</li><li>适当使用代理可以简化流程，但是会在隐式转型的地方出错</li><li>类型擦除:使用虚基类(接口)</li><li>double dispatch:(针对不同动态类型的多个object产生不同副作用)<ul><li>虚函数 + RTTI：无封装，可维护性为0</li><li>多重虚函数调用: 类似模板递归展开的手动实现，每次确定一个类型，然后调用下一个虚函数</li><li>手动实现虚函数表</li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;ul&gt;
&lt;li&gt;不能直接往数组类容器塞多态类，使用指针；一定要引用的情况下（需要&lt;code&gt;operator()&lt;/code&gt;）用std::reference&lt;/li&gt;
&lt;li&gt;直接创建数组或用vector,array等容器预先分配大小时调用类的无参(默认)构造函数，因此如果用</summary>
      
    
    
    
    <category term="C++" scheme="http://blog.vollate.top/categories/C/"/>
    
    
    <category term="Note" scheme="http://blog.vollate.top/tags/Note/"/>
    
  </entry>
  
  <entry>
    <title>CPP随笔</title>
    <link href="http://blog.vollate.top/2023/11/03/cpp-essay/"/>
    <id>http://blog.vollate.top/2023/11/03/cpp-essay/</id>
    <published>2023-11-03T03:20:31.000Z</published>
    <updated>2023-12-07T16:22:28.551Z</updated>
    
    <content type="html"><![CDATA[<p>记录cpp编程过程中的一些总结</p><h2 id="clang-libstdc-debug-问题">clang + libstdc++ debug 问题</h2><p>众所周知 LLVM 的 <code>libc++</code> 和 GNU 的 <code>libstdc++</code> 是两个不同的标准库实现。虽然使用 clang + libstdc++ 编译也可以使用 LLDB 对程序进行 debug，但是字符串以及一些数据结构如 <code>unordered_map</code> 无法正确显示值。解决方式是换  <code>libc++</code>,在 cmake 中可以使用 <code>set(CMAKE_CXX_FLAGS &quot;$&#123;CMAKE_CXX_FLAGS&#125; -stdlib=libc++&quot;)</code> 来解决。</p><p>顺带记点 cmake 中切换到 llvm 全套工具链的方式:</p><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="string">&quot;$&#123;CMAKE_CXX_COMPILER_ID&#125;&quot;</span> <span class="keyword">STREQUAL</span> <span class="string">&quot;Clang&quot;</span>)</span><br><span class="line">    <span class="keyword">set</span>(CMAKE_CXX_FLAGS <span class="string">&quot;-stdlib=libc++&quot;</span>)</span><br><span class="line">    <span class="keyword">set</span>(CMAKE_EXE_LINKER_FLAGS <span class="string">&quot;-fuse-ld=lld&quot;</span>)</span><br><span class="line"><span class="keyword">endif</span> ()</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;记录cpp编程过程中的一些总结&lt;/p&gt;
&lt;h2 id=&quot;clang-libstdc-debug-问题&quot;&gt;clang + libstdc++ debug 问题&lt;/h2&gt;
&lt;p&gt;众所周知 LLVM 的 &lt;code&gt;libc++&lt;/code&gt; 和 GNU 的 &lt;code&gt;libs</summary>
      
    
    
    
    <category term="C++" scheme="http://blog.vollate.top/categories/C/"/>
    
    
    <category term="Essay" scheme="http://blog.vollate.top/tags/Essay/"/>
    
  </entry>
  
  <entry>
    <title>Effective C++</title>
    <link href="http://blog.vollate.top/2023/10/05/effective-cpp/"/>
    <id>http://blog.vollate.top/2023/10/05/effective-cpp/</id>
    <published>2023-10-05T08:03:48.000Z</published>
    <updated>2023-12-07T16:22:28.551Z</updated>
    
    <content type="html"><![CDATA[<p>从vimwiki迁移过来的古早笔记,仔细看看发现好多忘了(</p><pre><code>Items from 1 to 55</code></pre><hr><ol><li><p>将cpp看作C，面向对象的cpp，模板和STL四个部分；根据各个部分的不同特性选择不同的编程方式</p></li><li><p>能用const，enum，inline就别#define</p></li><li><p>能用const就用const</p></li><li><p>确保类初始化后再使用</p><ul><li>尽可能使用列表初始化(原因:operator= first call class’s default consturctor to allocate memory and get address, then do variable assigment)</li><li>避免初始化顺序问题（有关static初始化的问题）</li></ul></li><li><p>知道默认构造，析构，复制构造函数</p><ul><li>一旦创建移动构造||移动赋值操作符，不会生成默认复制构造&amp;&amp;复制运算符，反之亦然</li></ul></li><li><p>小心使用默认生成的类函数</p></li><li><p>若要使用多态，则应将基类析构函数定义为virtual</p></li><li><p>不要让异常离开析构函数</p></li><li><p>不要在构造和析构函数中调用虚函数</p><ul><li>也不是不能用，注意用的时候的类型是基类还是派生类（容易出问题所以不建议用）</li></ul></li><li><p>重载运算符建议返回*this以便连等及其它操作</p></li><li><p>重载操作符时要考虑自己对自己操作的情况</p><ul><li>处理方法：<ol><li>先判断地址</li><li>拷贝后操作拷贝</li></ol></li></ul></li><li><p>拷贝（复制运算符）要完全复制类的内容（包括基类的）</p><ul><li>要复用代码，不要相互调用复制构造函数，而是共同调用一个三方函数</li></ul></li><li><p>RAII: use class to manage resource(<code>unique_ptr &amp; share_ptr</code>)</p></li><li><p>RAII object have specified copy function</p></li><li><p>访问RAII class数据：</p><ul><li>隐式：更方便</li><li>显示：更安全</li></ul></li><li><p>成对使用对应的 <code>new([])</code> &amp; <code>delete([])</code></p></li><li><p>单独创建智能指针<br><code>eg: A(std::unique_ptr&lt;B&gt;(new B), fuc())</code></p><ul><li>智能指针创建需要接受 <code>new</code> 返回的地址，而类构造函数执行顺序由编译器决定，如果<code>fuc</code> throw exception,会导致内存泄漏</li></ul></li><li><p>设计良好的interface</p><ul><li>尽可能不让用户写出出错代码</li><li>减少用户碰到管理内存的几率</li><li>shared_ptr总是使用指向类的析构函数，可以防止cross-DLL(object creat in a dynamic link library but delete in a differet DLL)</li></ul></li><li><p>定义类就是定义类型，关注一些细节</p></li><li><p>尽量传const&amp;,对基础类型直接传值(iterator实现是指针，也算)</p></li><li><p>不要返回指向本地临时变量的指针</p></li><li><p>对用户隐藏数据，protected没比public包装好到哪去</p></li><li><p>不用访问data的就别搞成成员函数</p></li><li><p>类型转换需要非成员函数(<code>friend</code>)</p></li><li><p>创建合适的swap函数：</p><ul><li>默认的std::swap执行三次拷贝构造-&gt;解决方案：构造wapper类使用指针来存储数据，交换仅交换指针，并且提供public的swap成员函数</li><li>如果该类不是模板类，需要具体化std::swap给该类;如果该类是模板类则在namespace中重写swap（模板函数）</li><li>调用规则：using <em>+ using std::swap，调用优先级为 模板swap&gt;具体化std::swap&gt;std::swap,因此记得using</em> 和using std::swap</li></ul></li><li><p>尽可能延缓变量的定义（看情况而定）好处：<br>- 避免无用变量构造消耗时间（throw会导致无用<br>- 优化默认构造+复制构造为复制构造</p></li><li><p>尽可能不用cast，尤其dynamic_cast；必须要用，定义函数来隐藏cast（尽量避免用户自己cast）；少用c类型的转型, c++四种cast</p><ul><li>const_cast</li><li>dynamic_cast</li><li>reinterpret_cast</li><li>static_cast<ul><li>static_cast子类转成父类时是产生一个子类中父类的临时拷贝，修改不会映射到原存储</li></ul></li></ul><blockquote><p>cast要小心，搞清楚自己的目的</p></blockquote></li><li><p>尽可能避免返回句柄[引用和指针]</p><ul><li>指向栈中临时变量会寄掉</li></ul></li><li><p>exception safety:</p><ul><li>No resource leak</li><li>No data structures become coorupted</li></ul><p>exception safety function:</p><ol><li>Basic guarantee: after throw, everything in program remain valid</li><li>Strong guarantee: after exception, the program status remain as if the fuction is never called</li><li>Nothrow guarantee: never throw exception(hard to guarantee out of C part in C++)</li></ol><ul><li>Strong guarantee implement: make a copy and modify the copy, then swap them in noexception way(But this need more resource and time, though it’s highly recommand, not always need to provide strong guarantee)</li><li>一般函数需要提供至少要有weak exception guarantee(at least no resource leak)</li></ul></li><li><p>inline function rules:</p><ul><li>limit inline function as small, frequently called functions.</li><li>内联别用模板<br>其它一些东西：<ul><li>一般构造和析构函数不是内联</li><li>能不能内联主要看编译器</li></ul></li></ul></li><li><p>最小化编译依赖关系（通过声明）可以使用：</p><ol><li>handle class</li><li>interface class: increase memory cost for virtual function table<br>编译时只需要重新链接函数就行</li></ol></li><li><p>public inheritance means “is a”(noted that only public do this)</p></li><li><p>继承会隐藏父类（作用域）的变量和函数（当然名称空间也会{使用using解除隐藏</p></li><li><p>pure virtual function; virtual function;non-virtual function; 不要担心虚函数带来的损耗（大多数情况），也不要全是虚函数（一样）</p><ul><li>pure virtual function可以在类外提供实现，如此可以强制子类重写（算是强制注意吧）并减少代码重复</li><li>80~20rule:80% running time spend on 20% code</li></ul></li><li><p>使用none virtual interface idiom 在基类以确保多态在何时调用函数</p><ul><li>使用函数指针成员代替虚函数（好处：可以更改调用的函数(坏处：缺少对非public变量的访问权限</li><li>使用std::function成员代替虚函数</li></ul></li><li><p>重定义非虚函数可能会使得多态出现意想不到的问题(从设计上来说就不应该重定义非虚函数)</p></li><li><p>默认参数值为静态绑定，不同于虚函数的动态绑定，不要在继承中改变默认值</p></li><li><p>has a &amp; implemented in terms of-- composition</p></li><li><p>private inheritance当仅必要时<br>- both private inheritance and composition mean is-implemented-in-terms-of<br>- composition is easy to understand<br>- private inheritance can enable EBO<br>- empty base optomize(EBO):当仅单继承且父类是空类时，子类大小等于数据大小(编译器优化</p></li><li><p>多继承尽量别用，用要考虑virtual</p><ul><li>虚拟继承有损耗（比起单继承</li><li>多继承例子：public interface+private implementation</li></ul></li><li><p>类和模板都支持多态</p><ul><li>对于类，接口是明确的，多态出现在运行时</li><li>对于模板参数，接口是明确且基于合法的表达式的，多态出现在编译时（通过模板初始化和函数重载）</li></ul></li><li><p>typename和class可以互换</p><ul><li>在不清楚的情况下，C++默认把typename(class):😗**看成变量而不是类型，使用 <code>typename</code> 告诉他这是个变量类型</li></ul></li><li><p>访问模板基类函数的三种方法</p><ol><li>使用 <code>this</code> 指针调用</li><li><code>using</code> 指令</li><li><code>base&lt;T&gt;::**</code>直接用</li></ol></li><li><p>模板隐式具体化出的不依赖于模板参数的函数会导致程序膨胀</p><ul><li>若由非类型参数导致，将模板参数换为函数参数或者类成员变量</li><li>若由类型参数导致，可以将数据转化为 无类型指针 <code>eg: static_cast&lt;void*&gt;</code> 然后统一调用</li></ul></li><li><p>在模板类中使用模板成员函数来接受所有合法参数</p><ul><li>eg: 同模板不同具体化类的实例化的复制构造函数和复制运算符</li><li>注意：即使声明了模板复制构造函数，也要声明一般的复制构造函数</li></ul></li><li><p>我不知道他想说明啥</p></li><li><p>特化模板类使其对特定类型使用特定函数</p><ul><li>通过 <code>tyepid()</code> 检查—wrong, can’t compile<ul><li>由于不同的类型支持不同的函数，一些不支持的函数无法被编译（即使<code>if else</code>永远不会进入)编译过程要求所有代码合法</li></ul></li><li>通过和函数重载(编译时)</li></ul></li><li><p>TMP(template metaprogramming)</p><ul><li>将一部分运行时工作放到编译时进行</li></ul></li><li><p>通过 <code>set_new_handler(*new_handler)</code> 自定义new的行为 <code>typedef void (*new_handler)()</code> declear in std, use as <code>std::new_handler</code></p><ul><li>通过连锁调用在失败后尝试其他 <code>handler</code> 分配内存，最后全部失败再throw bad_alloc</li><li>自定义类new的行为: modify <code>void* operator new(std::size)throw(std::bad_alloc)</code> and <code>set_new_handler</code></li><li>C++93前new分配失败会返回0，使用 <code>new(std::nothrow)</code> 来启用这一行为（只作用于内存分配时，初始化相关对象仍可能throw</li></ul></li><li><p>重载new/delete操作符的几种情况</p><ol><li>优化操作速度</li><li>收集内存使用信息</li><li>减少开头和末尾的内存占用</li><li>自定义内存对齐</li><li>将类集束摆放</li><li>其他未列出new行为</li></ol></li><li><p>重载new和delete</p><ul><li>重载new需要一个无限循环来分配内存，并在失败时调用 <code>set_new_handler</code> 或者分配0空间并throw</li><li>对于类类型，应该分配比预期更大空间</li><li>delete对nullptr什么也不做，对类类型应该删除比预期更大空间</li></ul></li><li><p>重写new了记得重写delete，并且不要无意间隐藏了默认的new&amp;delete</p></li><li><p>注意编译警告，也不要过度依赖编译器</p></li><li><p>熟悉标准库，包括</p><ul><li>STL(standard template library)</li><li>Iostream</li><li>Internationlization(like wchar_t,wstring)</li><li>numeric provessing(valarray, complex)</li><li>exception hierarchy</li><li>C89 standard library</li><li>tr1(2005,Technical report 1), add smartPointers,function pointers(tr1::function,std::function now)就是std::expermental::xxx</li></ul></li><li><p>Boost organization and Boost library</p></li></ol><hr><p>This is just a begining, C++ learning will never end</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;从vimwiki迁移过来的古早笔记,仔细看看发现好多忘了(&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Items from 1 to 55
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;将cpp看作C，面向对象的cpp，模板和STL四个部分；根据各个部分的不同特性选择</summary>
      
    
    
    
    <category term="C++" scheme="http://blog.vollate.top/categories/C/"/>
    
    
    <category term="Note" scheme="http://blog.vollate.top/tags/Note/"/>
    
  </entry>
  
  <entry>
    <title>Book List</title>
    <link href="http://blog.vollate.top/2023/09/18/book-list/"/>
    <id>http://blog.vollate.top/2023/09/18/book-list/</id>
    <published>2023-09-18T04:18:11.000Z</published>
    <updated>2023-12-07T16:22:28.551Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Reading">Reading</h2><ul><li>C++ Currency in Action</li><li><s>Computer Organzation And Design</s> 摆了</li><li>RISCV-privileged</li></ul><h2 id="Plan-To-Read">Plan To Read</h2><ul><li>Effective Modern C++</li><li>C++ Templates ed.2</li></ul><h2 id="Shelve">Shelve</h2><ul><li>Deep learning</li></ul><h2 id="Finished">Finished</h2><table><thead><tr><th>Name</th><th>Finish date</th></tr></thead><tbody><tr><td>C++ Primer Plus</td><td>2021.12</td></tr><tr><td>Effective C++</td><td>2022.7</td></tr><tr><td>1984</td><td>2022.6</td></tr><tr><td>沙丘</td><td>2022.6</td></tr><tr><td>资本论</td><td>2022.8.1</td></tr><tr><td>地铁系列(203[3,5])</td><td>2022.9.25</td></tr><tr><td>More Effective C++</td><td>2023.1.22</td></tr><tr><td>The Fast Guide towards Modern C++</td><td>2023.7.15</td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Reading&quot;&gt;Reading&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;C++ Currency in Action&lt;/li&gt;
&lt;li&gt;&lt;s&gt;Computer Organzation And Design&lt;/s&gt; 摆了&lt;/li&gt;
&lt;li&gt;RISCV-privileged&lt;/</summary>
      
    
    
    
    <category term="None" scheme="http://blog.vollate.top/categories/None/"/>
    
    
    <category term="Book" scheme="http://blog.vollate.top/tags/Book/"/>
    
  </entry>
  
  <entry>
    <title>Tool List</title>
    <link href="http://blog.vollate.top/2023/03/27/tool-list/"/>
    <id>http://blog.vollate.top/2023/03/27/tool-list/</id>
    <published>2023-03-27T00:17:41.000Z</published>
    <updated>2023-12-07T16:22:28.555Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>收录了Linux下使用的一些工具</p></blockquote><h2 id="Screen-Shot-Recorder">Screen Shot/Recorder</h2><ul><li><a href="https://www.maartenbaert.be/simplescreenrecorder/">SimpleScreenRecorder</a></li><li><a href="https://obsproject.com/">OBS studio</a></li><li><a href="https://flameshot.org/">Flameshot</a></li></ul><h2 id="Cloud-Drive">Cloud Drive</h2><ul><li><a href="https://github.com/abraunegg/onedrive/tree/master">Onedrive</a></li><li><a href="https://github.com/bpozdena/OneDriveGUI">OnedriveGUI</a>: GUI for client above</li></ul><h2 id="Proxy">Proxy</h2><h3 id="Clash-Client">Clash Client</h3><ul><li><a href="https://github.com/Fndroid/clash_for_windows_pkg">cfw</a>(closed-source)</li><li><a href="https://github.com/zzzgydi/clash-verge">clash-verge</a>(open-source)</li></ul><blockquote><p>注意 Clash 和 Clash.Meta 是开源软件，clash.Premium 为 Clash 原作者在 Clash 基础上开发的闭源软件，介意误用</p></blockquote><h3 id="V2ray-Client">V2ray Client</h3><ul><li><a href="https://github.com/v2rayA/v2rayA">v2rayA</a>(open-source)</li></ul><h2 id="Diagram">Diagram</h2><ul><li><a href="https://app.diagrams.net/">drawio</a></li></ul><h2 id="Office">Office</h2><ul><li><a href="https://github.com/LibreOffice/core">libreoffice</a></li><li><a href="https://github.com/ONLYOFFICE/DesktopEditors">onlyoffice</a></li></ul><h2 id="Terminal-Resource-Monitor">Terminal Resource Monitor</h2><ul><li><a href="https://github.com/aristocratos/btop">btop</a> or <a href="https://github.com/aristocratos/bpytop">bpytop</a></li><li><a href="https://github.com/htop-dev/htop">htop</a></li></ul><h2 id="Diff-Tools">Diff Tools</h2><ul><li><a href="https://gitlab.gnome.org/GNOME/meld">meld</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;收录了Linux下使用的一些工具&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;Screen-Shot-Recorder&quot;&gt;Screen Shot/Recorder&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://www.maa</summary>
      
    
    
    
    
    <category term="Tools" scheme="http://blog.vollate.top/tags/Tools/"/>
    
  </entry>
  
  <entry>
    <title>文章/链接归档</title>
    <link href="http://blog.vollate.top/2022/11/10/blog-archives/"/>
    <id>http://blog.vollate.top/2022/11/10/blog-archives/</id>
    <published>2022-11-10T20:10:57.000Z</published>
    <updated>2023-12-07T16:22:28.551Z</updated>
    
    <content type="html"><![CDATA[<h2 id="OS">OS</h2><ul><li><a href="https://bbs.huaweicloud.com/blogs/279735">内存管理</a></li></ul><h2 id="Program">Program</h2><ul><li><a href="https://www.foonathan.net/2016/03/cmake-install/">CMake export lib</a></li><li><a href="https://www.cnblogs.com/pcdack/p/16019319.html">oneAPI|DPC++归档</a></li></ul><h2 id="Network">Network</h2><ul><li><a href="https://gfw.report/">GFW report</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;OS&quot;&gt;OS&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://bbs.huaweicloud.com/blogs/279735&quot;&gt;内存管理&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;Program&quot;&gt;Program&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;</summary>
      
    
    
    
    <category term="None" scheme="http://blog.vollate.top/categories/None/"/>
    
    
    <category term="Archive" scheme="http://blog.vollate.top/tags/Archive/"/>
    
  </entry>
  
  <entry>
    <title>Happy Runner (乐道不跑)</title>
    <link href="http://blog.vollate.top/2022/11/03/happy-runner/"/>
    <id>http://blog.vollate.top/2022/11/03/happy-runner/</id>
    <published>2022-11-03T02:57:19.000Z</published>
    <updated>2023-12-07T16:22:28.555Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Requirement">Requirement</h2><p>一部root了的安卓手机(解不了bl的可以试试太极)</p><blockquote><p>如何root建议google,据说小米开模糊定位不root也行，但是没试过(没有没root的手机)</p></blockquote><h2 id="Steps">Steps</h2><ol><li>下载<a href="http://fakeloc.cc/app">fake location</a>，链接挂了就上 github 搜</li><li>买高级版 (花钱)</li><li>设置里面把地图换成百度</li><li>路线模拟里面画路线，<s>建议把每个可能的打卡点都过一遍</s> 现在不用打卡了,差不多就行，注意别超过单次最大路程</li><li>开启路线模拟和乐跑，设置速度(注意别太快了)，建议开启浮动速度和模拟步频</li><li>记得到时间来关乐跑免得超时</li></ol><h2 id="问题排查">问题排查</h2><ul><li>开了模拟没反应: 换运行模式(root/no root)</li><li>乐跑闪退(root了的手机/模拟器): 对乐跑隐藏root(Magisk/fake location 内置)</li><li>目前最新版乐跑好像不能在模拟器中运行，大概是检测模拟器？</li><li>其他: 看文档, google，<s>我有一个朋友</s></li></ul><p><strong>本教程仅供参考，使用有风险，对于按照本教程操作造成被检测等等问题概不负责</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Requirement&quot;&gt;Requirement&lt;/h2&gt;
&lt;p&gt;一部root了的安卓手机(解不了bl的可以试试太极)&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;如何root建议google,据说小米开模糊定位不root也行，但是没试过(没有没root的手机)&lt;/p</summary>
      
    
    
    
    <category term="None" scheme="http://blog.vollate.top/categories/None/"/>
    
    
    <category term="Magic" scheme="http://blog.vollate.top/tags/Magic/"/>
    
    <category term="Tips" scheme="http://blog.vollate.top/tags/Tips/"/>
    
  </entry>
  
  <entry>
    <title>First Post</title>
    <link href="http://blog.vollate.top/2022/10/01/first-post/"/>
    <id>http://blog.vollate.top/2022/10/01/first-post/</id>
    <published>2022-10-01T03:12:59.000Z</published>
    <updated>2023-12-07T16:22:28.551Z</updated>
    
    <content type="html"><![CDATA[<p>总算整了个能看的blog界面</p><p>之前搭图床然后疯狂报错<br>最后发现发现设置nginx的时候location拼错了~~(不开高亮的下场)~~</p><p>总之捣鼓了快一个月想起来弄一下断断续续的终于配好了</p><p><img src="514.png" alt="恋恋可爱捏"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;总算整了个能看的blog界面&lt;/p&gt;
&lt;p&gt;之前搭图床然后疯狂报错&lt;br&gt;
最后发现发现设置nginx的时候location拼错了~~(不开高亮的下场)~~&lt;/p&gt;
&lt;p&gt;总之捣鼓了快一个月想起来弄一下断断续续的终于配好了&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;514.png&quot;</summary>
      
    
    
    
    <category term="None" scheme="http://blog.vollate.top/categories/None/"/>
    
    
  </entry>
  
</feed>
