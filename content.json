{"meta":{"title":"Vollate's Blog","subtitle":"","description":"Personal blog","author":"Vollate","url":"http://blog.vollate.top","root":"/"},"pages":[{"title":"About me","date":"2023-08-31T10:15:23.000Z","updated":"2023-11-14T10:22:13.260Z","comments":true,"path":"about/index.html","permalink":"http://blog.vollate.top/about/index.html","excerpt":"","text":"Coding 码农，24岁是学生 主用C++ Environment: GNU/Linux Shell: zsh Editor/IDE: Vim，Jetbrains 全家桶 Favorite Linux distriubtion: Arch, Debian Habbits 追/补番 轻小说 养老fps选手 躺平摸鱼"},{"title":"categories","date":"2023-08-31T10:14:48.000Z","updated":"2023-11-14T10:22:13.260Z","comments":false,"path":"categories/index.html","permalink":"http://blog.vollate.top/categories/index.html","excerpt":"","text":""},{"title":"links","date":"2023-08-31T10:45:18.000Z","updated":"2023-11-14T10:22:13.260Z","comments":true,"path":"links/index.html","permalink":"http://blog.vollate.top/links/index.html","excerpt":"","text":""},{"title":"repository","date":"2023-08-31T10:15:34.000Z","updated":"2023-11-14T10:22:13.260Z","comments":false,"path":"repository/index.html","permalink":"http://blog.vollate.top/repository/index.html","excerpt":"","text":""},{"title":"tags","date":"2023-08-31T10:12:46.000Z","updated":"2023-11-14T10:22:13.260Z","comments":false,"path":"tags/index.html","permalink":"http://blog.vollate.top/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"折腾博客记录","slug":"fiddle-blog","date":"2023-11-13T09:02:27.000Z","updated":"2023-11-14T10:22:13.252Z","comments":true,"path":"2023/11/13/fiddle-blog/","permalink":"http://blog.vollate.top/2023/11/13/fiddle-blog/","excerpt":"","text":"Github Action 样例 改了改 Hexo 官网的: 123456789101112131415161718192021222324252627282930name: Blogon: push: branches: - mainjobs: pages: runs-on: ubuntu-latest permissions: contents: write steps: - uses: actions/checkout@v3 with: token: $&#123;&#123; secrets.GITHUB_TOKEN &#125;&#125; submodules: true - name: Use Node.js 18.x uses: actions/setup-node@v2 with: node-version: &quot;18&quot; - name: Install Dependencies run: npm install - name: Build run: npm run build - name: Deploy uses: peaceiris/actions-gh-pages@v3 with: github_token: $&#123;&#123; secrets.GITHUB_TOKEN &#125;&#125; publish_dir: ./public Github Action 禁用 jekyll build 因为要用 peaceiris/actions-gh-pages@v3 进行部署，但是用的 Hexo 且已经在先前的操作编译完成，只需部署到对应分支即可。 一开始不知道 debug 了半天 解决方法在仓库里创建一个.nojekyll文件即可,这会自动仅用 jekyll build 使用cf后无限redirect 在 namesilo 买的域名，突发奇想试试用 Cloudflare 免费计划的域名解析（为了CDN） 配完后炸了，http 请求返回 301 导致无限 redirect，查了下原因如下： 服务器端使用了强制HTTPS，CloudFlare 的Flexible策略原理是：用户访问时使用HTTPS访问到CF的节点，然后CF通过HTTP方式回源到你的服务器去读取数据，这个时候对于你的服务器来说，CF就是访客，所以服务器返回的状态都是 301。解决方法很简单，将 SSL 策略设为 Full 或者 Full(strict) 就能解决。 Vanishvzone.me/897 上大学上的.jpg","categories":[{"name":"Network","slug":"Network","permalink":"http://blog.vollate.top/categories/Network/"}],"tags":[{"name":"Fiddle","slug":"Fiddle","permalink":"http://blog.vollate.top/tags/Fiddle/"}]},{"title":"More Effecitve C++","slug":"more-effecitve-cpp","date":"2023-11-08T08:21:57.000Z","updated":"2023-11-14T10:22:13.256Z","comments":true,"path":"2023/11/08/more-effecitve-cpp/","permalink":"http://blog.vollate.top/2023/11/08/more-effecitve-cpp/","excerpt":"","text":"不能直接往数组类容器塞多态类，使用指针；一定要引用的情况下（需要operator()）用std::reference 直接创建数组或用vector,array等容器预先分配大小时调用类的无参(默认)构造函数，因此如果用了explict记得声明无参构造函数 1234567//没有无参构造函数解法（别用）class Ex;void* ptr=operator new[](10*sizeof(Ex));for(int i=0;i!=10;++i) new (&amp;ptr[i]) Ex(...);//call constructor//Free memoryoperator delete(ptr); custom i++&amp;++i for class class foo;int foo operator++();//++iconst int foo operator++(int);//i++ 尽可能不重载 &amp;&amp;,|| and ,，因为不满足短路逻辑 有关new, new[],delete,delete[] new时，先调用void* operator new(size_t size)分配内存,然后初始化对象并且将void*转型为对应类型指针 operator new 的一个重载:void* operator new(size_t size, void* loaction) 定位new实现 delete时，先调用析构函数然后operator delete 释放内存 对数组: new []调用operator new[]()分配内存,然后为每个对象调用构造函数 delete[]同理 构造函数异常处理(未完全构造函数不会栈解退自动析构): 使用try catch进行清理 防止成员列表初始化const pointer异常导致资源泄漏的方法(未完全构造指针无法使用delete): 调用一个basic exception guarantee的函数 使用RAII类 异常 异常栈解退时调用析构函数再抛出异常将会导致程序直接终止(call terminate directly kill program) 异常拷贝时按照静态类型拷贝(派生类的基类引用拷贝为基类) 异常捕获的支持隐式转型(按指): 任何指针to void*(极其不建议用指针) 派生类转基类 总是按catch先后顺序捕获 按引用捕获可以实现多态 Improve proformance: lazy evaluation: 返回一个结果的代理类，只有在需要时才进行计算 lazy copy： 写时复制 lazy fetch：涉及到数据库的部分 over-eager evaluation：提前计算并存入缓存，或constexpr编译期计算 临时对象: 仅在按值传递对象或者传递常量引用参数时产生。返回对象时，若直接返回则会拷贝局部对象 返回值优化: 返回构造函数的参数，这样返回的对象会在返回的作用域构造(编译器优化) 判断类是否在堆中(为了确定能否调用delete this)：重载operator new,operator new[],记录返回的指针到一个图中，每次删除前进行查找是否在堆上 适当使用代理可以简化流程，但是会在隐式转型的地方出错 类型擦除:使用虚基类(接口) double dispatch:(针对不同动态类型的多个object产生不同副作用) 虚函数 + RTTI：无封装，可维护性为0 多重虚函数调用: 类似模板递归展开的手动实现，每次确定一个类型，然后调用下一个虚函数 手动实现虚函数表","categories":[{"name":"C++","slug":"C","permalink":"http://blog.vollate.top/categories/C/"}],"tags":[{"name":"Note","slug":"Note","permalink":"http://blog.vollate.top/tags/Note/"}]},{"title":"CPP随笔","slug":"cpp-essay","date":"2023-11-03T03:20:31.000Z","updated":"2023-11-14T10:22:13.252Z","comments":true,"path":"2023/11/03/cpp-essay/","permalink":"http://blog.vollate.top/2023/11/03/cpp-essay/","excerpt":"","text":"记录cpp编程过程中的一些总结和感想 含非智能指针类的注意事项 为含有指针的类的写函数是一个很麻烦的事情，总结了一下经验: 移动构造函数和移动赋值运算符：需要检查this!=&amp;that，防止自我赋值后把自己数据删除的情况。 涉及到资源的指针的拷贝，移动的：移动指针可能导致无法正常释放，拷贝指针可能导致外界使用悬空指针（释放过的指针） 所有会用到该类引用/指针的非const成员函数：同移动构造一样需要检查this!=&amp;that，防止函数执行过程中 that 数据改变影响自身数据。eg：假设有一个mString类，有一个insert(size_t index,size_t count, const mString&amp;)成员方法，如果进行a.insert(0,20,a)而内部实现使用循环插入就会出问题 所有会更改/依赖多个实例pointer的值进行操作的函数。eg:(std::swap) 带裸指针的类写起来非常头疼，一不小心就会出问题。建议非极度性能或特殊需求（写驱动等），或者折磨锻炼自己的情况还是乖乖用智能指针吧。","categories":[{"name":"C++","slug":"C","permalink":"http://blog.vollate.top/categories/C/"}],"tags":[{"name":"Essay","slug":"Essay","permalink":"http://blog.vollate.top/tags/Essay/"}]},{"title":"Effective C++","slug":"effective-cpp","date":"2023-10-05T08:03:48.000Z","updated":"2023-11-14T10:22:13.252Z","comments":true,"path":"2023/10/05/effective-cpp/","permalink":"http://blog.vollate.top/2023/10/05/effective-cpp/","excerpt":"","text":"从vimwiki迁移过来的古早笔记,仔细看看发现好多忘了( Items from 1 to 55 将cpp看作C，面向对象的cpp，模板和STL四个部分；根据各个部分的不同特性选择不同的编程方式 能用const，enum，inline就别#define 能用const就用const 确保类初始化后再使用 尽可能使用列表初始化(原因:operator= first call class’s default consturctor to allocate memory and get address, then do variable assigment) 避免初始化顺序问题（有关static初始化的问题） 知道默认构造，析构，复制构造函数 一旦创建移动构造||移动赋值操作符，不会生成默认复制构造&amp;&amp;复制运算符，反之亦然 小心使用默认生成的类函数 若要使用多态，则应将基类析构函数定义为virtual 不要让异常离开析构函数 不要在构造和析构函数中调用虚函数 也不是不能用，注意用的时候的类型是基类还是派生类（容易出问题所以不建议用） 重载运算符建议返回*this以便连等及其它操作 重载操作符时要考虑自己对自己操作的情况 处理方法： 先判断地址 拷贝后操作拷贝 拷贝（复制运算符）要完全复制类的内容（包括基类的） 要复用代码，不要相互调用复制构造函数，而是共同调用一个三方函数 RAII: use class to manage resource(unique_ptr &amp; share_ptr) RAII object have specified copy function 访问RAII class数据： 隐式：更方便 显示：更安全 成对使用对应的 new([]) &amp; delete([]) 单独创建智能指针 eg: A(std::unique_ptr&lt;B&gt;(new B), fuc()) 智能指针创建需要接受 new 返回的地址，而类构造函数执行顺序由编译器决定，如果fuc throw exception,会导致内存泄漏 设计良好的interface 尽可能不让用户写出出错代码 减少用户碰到管理内存的几率 shared_ptr总是使用指向类的析构函数，可以防止cross-DLL(object creat in a dynamic link library but delete in a differet DLL) 定义类就是定义类型，关注一些细节 尽量传const&amp;,对基础类型直接传值(iterator实现是指针，也算) 不要返回指向本地临时变量的指针 对用户隐藏数据，protected没比public包装好到哪去 不用访问data的就别搞成成员函数 类型转换需要非成员函数(friend) 创建合适的swap函数： 默认的std::swap执行三次拷贝构造-&gt;解决方案：构造wapper类使用指针来存储数据，交换仅交换指针，并且提供public的swap成员函数 如果该类不是模板类，需要具体化std::swap给该类;如果该类是模板类则在namespace中重写swap（模板函数） 调用规则：using + using std::swap，调用优先级为 模板swap&gt;具体化std::swap&gt;std::swap,因此记得using 和using std::swap 尽可能延缓变量的定义（看情况而定）好处： - 避免无用变量构造消耗时间（throw会导致无用 - 优化默认构造+复制构造为复制构造 尽可能不用cast，尤其dynamic_cast；必须要用，定义函数来隐藏cast（尽量避免用户自己cast）；少用c类型的转型, c++四种cast const_cast dynamic_cast reinterpret_cast static_cast static_cast子类转成父类时是产生一个子类中父类的临时拷贝，修改不会映射到原存储 cast要小心，搞清楚自己的目的 尽可能避免返回句柄[引用和指针] 指向栈中临时变量会寄掉 exception safety: No resource leak No data structures become coorupted exception safety function: Basic guarantee: after throw, everything in program remain valid Strong guarantee: after exception, the program status remain as if the fuction is never called Nothrow guarantee: never throw exception(hard to guarantee out of C part in C++) Strong guarantee implement: make a copy and modify the copy, then swap them in noexception way(But this need more resource and time, though it’s highly recommand, not always need to provide strong guarantee) 一般函数需要提供至少要有weak exception guarantee(at least no resource leak) inline function rules: limit inline function as small, frequently called functions. 内联别用模板 其它一些东西： 一般构造和析构函数不是内联 能不能内联主要看编译器 最小化编译依赖关系（通过声明）可以使用： handle class interface class: increase memory cost for virtual function table 编译时只需要重新链接函数就行 public inheritance means “is a”(noted that only public do this) 继承会隐藏父类（作用域）的变量和函数（当然名称空间也会{使用using解除隐藏 pure virtual function; virtual function;non-virtual function; 不要担心虚函数带来的损耗（大多数情况），也不要全是虚函数（一样） pure virtual function可以在类外提供实现，如此可以强制子类重写（算是强制注意吧）并减少代码重复 80~20rule:80% running time spend on 20% code 使用none virtual interface idiom 在基类以确保多态在何时调用函数 使用函数指针成员代替虚函数（好处：可以更改调用的函数(坏处：缺少对非public变量的访问权限 使用std::function成员代替虚函数 重定义非虚函数可能会使得多态出现意想不到的问题(从设计上来说就不应该重定义非虚函数) 默认参数值为静态绑定，不同于虚函数的动态绑定，不要在继承中改变默认值 has a &amp; implemented in terms of-- composition private inheritance当仅必要时 - both private inheritance and composition mean is-implemented-in-terms-of - composition is easy to understand - private inheritance can enable EBO - empty base optomize(EBO):当仅单继承且父类是空类时，子类大小等于数据大小(编译器优化 多继承尽量别用，用要考虑virtual 虚拟继承有损耗（比起单继承 多继承例子：public interface+private implementation 类和模板都支持多态 对于类，接口是明确的，多态出现在运行时 对于模板参数，接口是明确且基于合法的表达式的，多态出现在编译时（通过模板初始化和函数重载） typename和class可以互换 在不清楚的情况下，C++默认把typename(class):😗**看成变量而不是类型，使用 typename 告诉他这是个变量类型 访问模板基类函数的三种方法 使用 this 指针调用 using 指令 base&lt;T&gt;::**直接用 模板隐式具体化出的不依赖于模板参数的函数会导致程序膨胀 若由非类型参数导致，将模板参数换为函数参数或者类成员变量 若由类型参数导致，可以将数据转化为 无类型指针 eg: static_cast&lt;void*&gt; 然后统一调用 在模板类中使用模板成员函数来接受所有合法参数 eg: 同模板不同具体化类的实例化的复制构造函数和复制运算符 注意：即使声明了模板复制构造函数，也要声明一般的复制构造函数 我不知道他想说明啥 特化模板类使其对特定类型使用特定函数 通过 tyepid() 检查—wrong, can’t compile 由于不同的类型支持不同的函数，一些不支持的函数无法被编译（即使if else永远不会进入)编译过程要求所有代码合法 通过和函数重载(编译时) TMP(template metaprogramming) 将一部分运行时工作放到编译时进行 通过 set_new_handler(*new_handler) 自定义new的行为 typedef void (*new_handler)() declear in std, use as std::new_handler 通过连锁调用在失败后尝试其他 handler 分配内存，最后全部失败再throw bad_alloc 自定义类new的行为: modify void* operator new(std::size)throw(std::bad_alloc) and set_new_handler C++93前new分配失败会返回0，使用 new(std::nothrow) 来启用这一行为（只作用于内存分配时，初始化相关对象仍可能throw 重载new/delete操作符的几种情况 优化操作速度 收集内存使用信息 减少开头和末尾的内存占用 自定义内存对齐 将类集束摆放 其他未列出new行为 重载new和delete 重载new需要一个无限循环来分配内存，并在失败时调用 set_new_handler 或者分配0空间并throw 对于类类型，应该分配比预期更大空间 delete对nullptr什么也不做，对类类型应该删除比预期更大空间 重写new了记得重写delete，并且不要无意间隐藏了默认的new&amp;delete 注意编译警告，也不要过度依赖编译器 熟悉标准库，包括 STL(standard template library) Iostream Internationlization(like wchar_t,wstring) numeric provessing(valarray, complex) exception hierarchy C89 standard library tr1(2005,Technical report 1), add smartPointers,function pointers(tr1::function,std::function now)就是std::expermental::xxx Boost organization and Boost library This is just a begining, C++ learning will never end","categories":[{"name":"C++","slug":"C","permalink":"http://blog.vollate.top/categories/C/"}],"tags":[{"name":"Note","slug":"Note","permalink":"http://blog.vollate.top/tags/Note/"}]},{"title":"Book List","slug":"book-list","date":"2023-09-18T04:18:11.000Z","updated":"2023-11-14T10:22:13.252Z","comments":true,"path":"2023/09/18/book-list/","permalink":"http://blog.vollate.top/2023/09/18/book-list/","excerpt":"","text":"Reading C++ Currency in Action Computer Organzation And Design 摆了 RISCV-privileged Plan To Read Effective Modern C++ C++ Templates ed.2 Shelve Deep learning Finished Name Finish date C++ Primer Plus 2021.12 Effective C++ 2022.7 1984 2022.6 沙丘 2022.6 资本论 2022.8.1 地铁系列(203[3,5]) 2022.9.25 More Effective C++ 2023.1.22 The Fast Guide towards Modern C++ 2023.7.15","categories":[],"tags":[{"name":"Book","slug":"Book","permalink":"http://blog.vollate.top/tags/Book/"}]},{"title":"Tool List","slug":"tool-list","date":"2023-03-27T00:17:41.000Z","updated":"2023-11-14T10:22:13.256Z","comments":true,"path":"2023/03/27/tool-list/","permalink":"http://blog.vollate.top/2023/03/27/tool-list/","excerpt":"","text":"收录了Linux下使用的一些工具 Screen Shot/Recorder SimpleScreenRecorder OBS studio Flameshot Cloud Drive Onedrive OnedriveGUI: GUI for client above Proxy Clash Client cfw(closed-source) clash-verge(open-source) 注意 Clash 和 Clash.Meta 是开源软件，clash.Premium 为 Clash 原作者在 Clash 基础上开发的闭源软件，介意误用 V2ray Client v2rayA(open-source) Diagram drawio Office libreoffice onlyoffice Terminal Resource Monitor btop or bpytop htop","categories":[],"tags":[{"name":"Tools","slug":"Tools","permalink":"http://blog.vollate.top/tags/Tools/"},{"name":"Linux","slug":"Linux","permalink":"http://blog.vollate.top/tags/Linux/"}]},{"title":"文章/链接归档","slug":"blog-archives","date":"2022-11-10T20:10:57.000Z","updated":"2023-11-14T10:22:13.252Z","comments":true,"path":"2022/11/10/blog-archives/","permalink":"http://blog.vollate.top/2022/11/10/blog-archives/","excerpt":"","text":"OS 内存管理 Program CMake export lib oneAPI|DPC++归档 Network GFW report","categories":[{"name":"Archive","slug":"Archive","permalink":"http://blog.vollate.top/categories/Archive/"}],"tags":[{"name":"Archive","slug":"Archive","permalink":"http://blog.vollate.top/tags/Archive/"}]},{"title":"Happy Runner (乐道不跑)","slug":"happy-runner","date":"2022-11-03T02:57:19.000Z","updated":"2023-11-14T10:22:13.256Z","comments":true,"path":"2022/11/03/happy-runner/","permalink":"http://blog.vollate.top/2022/11/03/happy-runner/","excerpt":"","text":"Requirement 一部root了的安卓手机(解不了bl的可以试试太极) 如何root建议google,据说小米开模糊定位不root也行，但是没试过(没有没root的手机) Steps 下载fake location，链接挂了就上 github 搜 买高级版 (花钱) 设置里面把地图换成百度 路线模拟里面画路线，建议把每个可能的打卡点都过一遍 现在不用打卡了,差不多就行，注意别超过单次最大路程 开启路线模拟和乐跑，设置速度(注意别太快了)，建议开启浮动速度和模拟步频 记得到时间来关乐跑免得超时 问题排查 开了模拟没反应: 换运行模式(root/no root) 乐跑闪退(root了的手机/模拟器): 对乐跑隐藏root(Magisk/fake location 内置) 目前最新版乐跑好像不能在模拟器中运行，大概是检测模拟器？ 其他: 看文档, google，我有一个朋友 本教程仅供参考，使用有风险，对于按照本教程操作造成被检测等等问题概不负责","categories":[{"name":"Tips","slug":"Tips","permalink":"http://blog.vollate.top/categories/Tips/"}],"tags":[{"name":"Magic","slug":"Magic","permalink":"http://blog.vollate.top/tags/Magic/"}]},{"title":"First Post","slug":"first-post","date":"2022-10-01T03:12:59.000Z","updated":"2023-11-14T10:22:13.256Z","comments":true,"path":"2022/10/01/first-post/","permalink":"http://blog.vollate.top/2022/10/01/first-post/","excerpt":"","text":"总算整了个能看的blog界面 之前搭图床然后疯狂报错 最后发现发现设置nginx的时候location拼错了~~(不开高亮的下场)~~ 总之捣鼓了快一个月想起来弄一下断断续续的终于配好了","categories":[],"tags":[]}],"categories":[{"name":"Network","slug":"Network","permalink":"http://blog.vollate.top/categories/Network/"},{"name":"C++","slug":"C","permalink":"http://blog.vollate.top/categories/C/"},{"name":"Archive","slug":"Archive","permalink":"http://blog.vollate.top/categories/Archive/"},{"name":"Tips","slug":"Tips","permalink":"http://blog.vollate.top/categories/Tips/"}],"tags":[{"name":"Fiddle","slug":"Fiddle","permalink":"http://blog.vollate.top/tags/Fiddle/"},{"name":"Note","slug":"Note","permalink":"http://blog.vollate.top/tags/Note/"},{"name":"Essay","slug":"Essay","permalink":"http://blog.vollate.top/tags/Essay/"},{"name":"Book","slug":"Book","permalink":"http://blog.vollate.top/tags/Book/"},{"name":"Tools","slug":"Tools","permalink":"http://blog.vollate.top/tags/Tools/"},{"name":"Linux","slug":"Linux","permalink":"http://blog.vollate.top/tags/Linux/"},{"name":"Archive","slug":"Archive","permalink":"http://blog.vollate.top/tags/Archive/"},{"name":"Magic","slug":"Magic","permalink":"http://blog.vollate.top/tags/Magic/"}]}